// -*- C++ -*- Time-stamp: <07/09/06 23:42:19 ptr>

/*
 * Copyright (c) 1997-1999, 2002, 2003, 2005-2007
 * Petr Ovtchenkov
 *
 * Portion Copyright (c) 1999-2001
 * Parallel Graphics Ltd.
 *
 * Licensed under the Academic Free License version 3.0
 *
 */

#ifndef __SOCKSTREAM__
#define __SOCKSTREAM__

#ifndef __config_feature_h
#include <config/feature.h>
#endif

#if !defined(__sun) && !defined(_WIN32) // i.e. __linux and __hpux
#include <sys/poll.h> // pollfd
#endif

#ifndef __XMT_H
#include <mt/xmt.h>
#endif

#include <netdb.h>
#include <netinet/in.h>

#include <iosfwd>
#include <ios>
#include <streambuf>
#include <iostream>
#include <string>
#include <stdexcept>

#ifdef WIN32
#  include <winsock2.h>
#else // WIN32
#  include <unistd.h>
#  include <sys/types.h>
#  if defined(__hpux) && !defined(_INCLUDE_XOPEN_SOURCE_EXTENDED)
#    define _INCLUDE_XOPEN_SOURCE_EXTENDED
#  endif
#  include <sys/socket.h>
#  if !defined(__UCLIBC__) && !defined(__FreeBSD__) && !defined(__OpenBSD__) && !defined(__NetBSD__)
#   include <stropts.h>
#  endif
#  ifdef __sun
#    include <sys/conf.h>
#  endif
#  include <netinet/in.h>
#  include <arpa/inet.h>
#  include <netdb.h>
#  ifdef __hpux
// #    ifndef socklen_t // HP-UX 10.01
// typedef int socklen_t;
// #    endif
#  endif
#  include <cerrno>
#endif // !WIN32

#include <sockios/netinfo.h>

#ifdef STLPORT
_STLP_BEGIN_NAMESPACE
#else
namespace std {
#endif

class sock_base
{
  public:
    typedef unsigned long shutdownflg;
#ifdef __unix
    typedef int           socket_type;
#endif
#ifdef WIN32
    typedef SOCKET        socket_type;
#endif

    enum stype {
      sock_stream	= SOCK_STREAM,    // stream socket
      sock_dgram	= SOCK_DGRAM,     // datagram socket
      sock_raw	        = SOCK_RAW,       // raw-protocol interface
      sock_rdm	        = SOCK_RDM,       // reliably-delivered message
      sock_seqpacket    = SOCK_SEQPACKET  // sequenced packet stream
    };

    enum protocol {
      local,                              // local to host (pipes, portals)
      inet                                // internetwork: UDP, TCP, etc.
    };

    // Option flags per-socket.
    enum so_t {
      so_debug	        = SO_DEBUG,       // turn on debugging info recording
#ifndef __linux
      so_acceptconn     = SO_ACCEPTCONN,  // socket has had listen()
#endif
      so_reuseaddr	= SO_REUSEADDR,   // allow local address reuse
      so_keepalive	= SO_KEEPALIVE,   // keep connections alive
      so_dontroute	= SO_DONTROUTE,   // just use interface addresses
      so_broadcast	= SO_BROADCAST,   // permit sending of broadcast msgs
#ifndef __linux
      so_useloopback    = SO_USELOOPBACK, // bypass hardware when possible
#endif
      so_linger	        = SO_LINGER,      // linger on close if data present
      so_oobinline	= SO_OOBINLINE,   // leave received OOB data in line
      // Additional options, not kept in so_options.
      so_sndbuf		= SO_SNDBUF,      // send buffer size
      so_rcvbuf		= SO_RCVBUF,      // receive buffer size
      so_sndlowat       = SO_SNDLOWAT,    // send low-water mark
      so_rcvlowat       = SO_RCVLOWAT,    // receive low-water mark
      so_sndtimeo       = SO_SNDTIMEO,    // send timeout
      so_rcvtimeo       = SO_RCVTIMEO,    // receive timeout
      so_error		= SO_ERROR,       // get error status and clear
      so_type		= SO_TYPE         // get socket type
#ifdef __sun // indeed HP-UX 11.00 also has it, but 10.01 not
                                 ,
      so_prototype      = SO_PROTOTYPE    // get/set protocol type
#endif
    };

    // Level number for (get/set)sockopt() to apply to socket itself.
//    enum _level {
//      sol_socket        = SOL_SOCKET
//    };

    enum shutdownflags {
      stop_in  = 0x1,
      stop_out = 0x2
    };

#ifdef WIN32
    class Init
    {
        // sometimes I need Init outside sock_base...
        // private:
      public:
	__FIT_DECLSPEC Init();
	__FIT_DECLSPEC ~Init();

        friend class sock_base;
    };

  protected:
    __FIT_DECLSPEC sock_base();
    __FIT_DECLSPEC ~sock_base();
#endif
};

template<class charT, class traits, class _Alloc>
class basic_sockbuf :
	public basic_streambuf<charT, traits>
{
  public:
    typedef basic_ios<charT, traits>       ios_type;
    typedef basic_sockbuf<charT, traits, _Alloc> sockbuf_type;
    typedef typename traits::state_type    state_t;
#ifdef WIN32
    typedef u_short                        family_type;
#else
#  ifdef sa_family_t
    typedef sa_family_t                    family_type;
#  else // HP-UX 10.01
    typedef unsigned short                 family_type;
#  endif
#endif
    
  public:
  /* Inherited from basic_streambuf : */
    typedef charT                      char_type;
    typedef typename traits::int_type  int_type;
    typedef typename traits::pos_type  pos_type;
    typedef typename traits::off_type  off_type;
    typedef traits                     traits_type;
  /*  */
      
    basic_sockbuf() :
        _fd( -1 ),
#if !defined(STLPORT) && defined(__GNUC__)
#if ((__GNUC__ < 3) || ((__GNUC__ == 3) && (__GNUC_MINOR__ < 4))) // hmm, 3.3.6 
        _mode( ios_base::openmode(__ios_flags::_S_in | __ios_flags::_S_out) ),
#else  // 4.1.1
        _mode( _S_in | _S_out ),
#endif // __GNUC__
#else  // STLPORT
        _mode( 0 ),
#endif // STLPORT
        _bbuf(0), _ebuf(0), _allocated( true )
      // , _doclose( true )
      {
#ifdef __FIT_POLL
        _timeout = -1;
#endif
#ifdef __FIT_SELECT
        _timeout_ref = 0;
#endif
      }
    basic_sockbuf( const char *hostname, int port,
                   sock_base::stype type = sock_base::sock_stream,
                   sock_base::protocol prot = sock_base::inet,
                   const timespec *timeout = 0 ) :
        _fd( -1 ),
#if !defined(STLPORT) && defined(__GNUC__)
#if ((__GNUC__ < 3) || ((__GNUC__ == 3) && (__GNUC_MINOR__ < 4)))
        _mode( ios_base::openmode(__ios_flags::_S_in | __ios_flags::_S_out) ),
#else  // 4.1.1
        _mode( _S_in | _S_out ),
#endif // __GNUC__
#else  // STLPORT
        _mode( 0 ),
#endif // STLPORT
        _bbuf(0), _ebuf(0), _allocated( true )
      // , _doclose( true )
      {
        open( hostname, port, type, prot, timeout );
      }
    basic_sockbuf( const in_addr& addr, int port,
                   sock_base::stype type = sock_base::sock_stream,
                   sock_base::protocol prot = sock_base::inet,
                   const timespec *timeout = 0 ) :
        _fd( -1 ),
#if !defined(STLPORT) && defined(__GNUC__)
#if ((__GNUC__ < 3) || ((__GNUC__ == 3) && (__GNUC_MINOR__ < 4)))
        _mode( ios_base::openmode(__ios_flags::_S_in | __ios_flags::_S_out) ),
#else  // 4.1.1
        _mode( _S_in | _S_out ),
#endif // __GNUC__
#else  // STLPORT
        _mode( 0 ),
#endif // STLPORT
        _bbuf(0), _ebuf(0), _allocated( true )
      // , _doclose( true )
      {
        open( addr, type, prot, timeout );
      }
    virtual ~basic_sockbuf()
      {
        close();
        _M_deallocate_block();
      }

    bool is_open() const
      { return _fd != -1; }

    sockbuf_type *open( const char *hostname, int port,
                        sock_base::stype type = sock_base::sock_stream,
                        sock_base::protocol prot = sock_base::inet,
                        const timespec *timeout = 0 );

    sockbuf_type *open( const in_addr& addr, int port,
                        sock_base::stype type = sock_base::sock_stream,
                        sock_base::protocol prot = sock_base::inet,
                        const timespec *timeout = 0 );

    sockbuf_type *open( sock_base::socket_type s,
                        sock_base::stype t = sock_base::sock_stream,
                        const timespec *timeout = 0 );

    sockbuf_type *open( sock_base::socket_type s, const sockaddr& addr,
                        sock_base::stype t = sock_base::sock_stream,
                        const timespec *timeout = 0 );

    sockbuf_type *attach( sock_base::socket_type s,
                          sock_base::stype t = sock_base::sock_stream,
                          const timespec *timeout = 0 );

    sockbuf_type *attach( sock_base::socket_type s, const sockaddr& addr,
                          sock_base::stype t = sock_base::sock_stream,
                          const timespec *timeout = 0 );

    sockbuf_type *close();
    void shutdown( sock_base::shutdownflg dir );

    sock_base::socket_type fd() const { return _fd;}

    family_type family() const
      { return /* is_open() ? */ _address.any.sa_family /* : 0 */; }

    int port() const
      { return /* is_open() && */ _address.any.sa_family == AF_INET ?
          _address.inet.sin_port : 0; }

    unsigned long inet_addr() const
      { return /* is_open() && */ _address.any.sa_family == AF_INET ?
          _address.inet.sin_addr.s_addr : 0; }

    const sockaddr_in& inet_sockaddr() const throw( std::domain_error )
      {
        if ( _address.any.sa_family != AF_INET ) {
          throw domain_error( "socket not belongs to inet type" );
        }
        return /* is_open() && */ _address.inet;
      }

   sock_base::stype stype() const
      { return _type; }

    // const string& hostname() const
    // { return _hostname; }

  protected:
    // bool findhost( const char *hostname );

    virtual streamsize showmanyc()
      { return this->egptr() - this->gptr(); }

    virtual int_type underflow();
    virtual int_type overflow( int_type c = traits::eof() );
    virtual int_type pbackfail( int_type c = traits::eof() )
      {
        if ( !is_open() )
          return traits::eof();

        if ( this->gptr() <= this->eback() ) {
          return traits::eof();
        }

        this->gbump(-1);
        if ( !traits::eq_int_type(c,traits::eof()) ) {
          *this->gptr() = traits::to_char_type(c);
          return c;
        }

        return traits::not_eof(c);
      }

    // Buffer managment and positioning:
    virtual basic_streambuf<charT, traits> *setbuf(char_type *s, streamsize n )
      {
        if ( s != 0 && n != 0 ) {
          _M_deallocate_block();
          _allocated = false;
          _bbuf = s;
          _ebuf = s + n;
        }
        return this;
      }

    virtual int sync();
    virtual streamsize xsputn(const char_type *s, streamsize n);

  public:
    xmt::mutex _M_lock_w; // lock for writing

  private: // Helper functions
    charT* _bbuf;
    charT* _ebuf;
    bool _allocated; // true, if _bbuf should be deallocated
#ifdef __FIT_POLL
    pollfd pfd;
    int  _timeout; // milliseconds
#endif
#ifdef __FIT_SELECT
    fd_set pfd;
    struct timeval _timeout;
    struct timeval *_timeout_ref;
#endif

    // Precondition: 0 < __n <= max_size().
    charT* _M_allocate( size_t __n ) { return _M_data_allocator.allocate(__n); }
    void _M_deallocate( charT* __p, size_t __n )
      { if (__p) _M_data_allocator.deallocate(__p, __n); }

    void _M_allocate_block(size_t __n)
      {
        if ( _allocated ) {
          if ( __n <= max_size() ) {
            _bbuf = _M_allocate(__n);
            _ebuf = _bbuf + __n;
            // _STLP_ASSERT( __n > 0 ? _bbuf != 0 : _bbuf == 0 );
          } else
            this->_M_throw_length_error();
        }
      }

    void _M_deallocate_block()
      { if ( _allocated ) _M_deallocate(_bbuf, _ebuf - _bbuf); }
  
    size_t max_size() const { return (size_t(-1) / sizeof(charT)) - 1; }

#ifdef STLPORT
    void _M_throw_length_error() const
      { _STLP_THROW(length_error("basic_sockbuf")); }
#else
    void _M_throw_length_error() const
      { throw length_error("basic_sockbuf"); }
#endif

#ifdef STLPORT
    typedef typename _Alloc_traits<charT, _Alloc>::allocator_type allocator_type;
#else
    typedef _Alloc allocator_type;
#endif
    /* typedef __allocator<charT, _Alloc> _Alloc_type; */

    /* _Alloc_type */ allocator_type _M_data_allocator;    

  private:
    typedef basic_sockbuf<charT,traits,_Alloc> _Self_type;
    int (basic_sockbuf<charT,traits,_Alloc>::*_xwrite)( const void *, size_t );
    int (basic_sockbuf<charT,traits,_Alloc>::*_xread)( void *, size_t );
    int write( const void *buf, size_t n )
#ifndef WIN32
      { return ::write( _fd, buf, n ); }
#else
      { return ::send( _fd, (const char *)buf, n, 0 ); }
#endif
    int send( const void *buf, size_t n )
#ifdef WIN32
      { return ::send( _fd, (const char *)buf, n, 0 ); }
#else
      { return ::send( _fd, buf, n, 0 ); }
#endif
    int sendto( const void *buf, size_t n )
#ifdef WIN32
      { return ::sendto( _fd, (const char *)buf, n, 0, &_address.any, sizeof( sockaddr_in ) ); }
#else
      { return ::sendto( _fd, buf, n, 0, &_address.any, sizeof( sockaddr_in ) ); }
#endif

    int read( void *buf, size_t n )
#ifdef WIN32
      { return ::recv( _fd, (char *)buf, n, 0  ); }
#else
      { return ::read( _fd, buf, n ); }
#endif
    int recv( void *buf, size_t n )
#ifdef WIN32
      { return ::recv( _fd, (char *)buf, n, 0  ); }
#else
      { return ::recv( _fd, buf, n, 0 ); }
#endif
    int recvfrom( void *buf, size_t n );
    void __hostname();

    sock_base::socket_type _fd;
    union sockaddr_t {
        sockaddr_in inet;
        sockaddr    any;
    } _address;

    ios_base::openmode  _mode;
    int                 _errno;
    sock_base::stype    _type;
    // bool                _doclose;
};

template <class charT, class traits, class _Alloc>
class basic_sockstream :
	public sock_base,
	public basic_iostream<charT,traits>
{
  public:
    /* Inherited from basic_iostream
    typedef charT                     char_type;
    typedef typename traits::int_type int_type;
    typedef typename traits::pos_type pos_type;
    typedef typename traits::off_type off_type;
    */
    basic_sockstream() :
        sock_base(),
        basic_iostream<charT,traits>( 0 )
	  { basic_ios<charT,traits>::init(&_sb); }
    basic_sockstream( const char *hostname, int port,
                      sock_base::stype type = sock_base::sock_stream,
                      sock_base::protocol pro = sock_base::inet,
                      const timespec *timeout = 0 ) :
        sock_base(),
        basic_iostream<charT,traits>( 0 )
      {
        basic_ios<charT,traits>::init(&_sb);
        basic_iostream<charT,traits>::clear();
        if ( _sb.open( hostname, port, type, pro, timeout ) == 0 ) {
          basic_ios<charT,traits>::setstate( ios_base::failbit | ios_base::badbit );
        }
      }

    basic_sockstream( const in_addr& addr, int port,
                      sock_base::stype type = sock_base::sock_stream,
                      sock_base::protocol pro = sock_base::inet,
                      const timespec *timeout = 0 ) :
        sock_base(),
        basic_iostream<charT,traits>( 0 )
      {
        basic_ios<charT,traits>::init(&_sb);
        basic_iostream<charT,traits>::clear();
        if ( _sb.open( addr, port, type, pro, timeout ) == 0 ) {
          basic_ios<charT,traits>::setstate( ios_base::failbit | ios_base::badbit );
        }
      }

    basic_sockstream( sock_base::socket_type s, const sockaddr& addr,
                      sock_base::stype type = sock_base::sock_stream,
                      const timespec *timeout = 0 ) :
        sock_base(),
        basic_iostream<charT,traits>( 0 )
      {
        basic_ios<charT,traits>::init(&_sb);
        basic_iostream<charT,traits>::clear();
        if ( _sb.open( s, addr, type, timeout ) == 0 ) {
          basic_ios<charT,traits>::setstate( ios_base::failbit | ios_base::badbit );
        }
      }

    basic_sockstream( sock_base::socket_type s,
                      sock_base::stype type = sock_base::sock_stream,
                      const timespec *timeout = 0 ) :
        sock_base(),
        basic_iostream<charT,traits>( 0 )
      {
        basic_ios<charT,traits>::init(&_sb);
        basic_iostream<charT,traits>::clear();
        if ( _sb.open( s, type, timeout ) == 0 ) {
          basic_ios<charT,traits>::setstate( ios_base::failbit | ios_base::badbit );
        }
      }

    basic_sockbuf<charT,traits,_Alloc>* rdbuf() const
      { return const_cast<basic_sockbuf<charT,traits,_Alloc>*>(&_sb); }
    bool is_open() const
      { return _sb.is_open(); }
    void open( const char *hostname, int port,
               sock_base::stype type = sock_base::sock_stream,
               sock_base::protocol pro = sock_base::inet,
               const timespec *timeout = 0 )
      {
        basic_iostream<charT,traits>::clear();
        if ( _sb.open( hostname, port, type, pro, timeout ) == 0 ) {
          basic_ios<charT,traits>::setstate( ios_base::failbit | ios_base::badbit );
        }
      }

    void open( const in_addr& addr, int port,
               sock_base::stype type = sock_base::sock_stream,
               sock_base::protocol pro = sock_base::inet,
               const timespec *timeout = 0 )
      {
        basic_iostream<charT,traits>::clear();
        if ( _sb.open( addr, port, type, pro, timeout ) == 0 ) {
          basic_ios<charT,traits>::setstate( ios_base::failbit | ios_base::badbit );
        }
      }

    // only for sock_stream : inet now!
    void open( sock_base::socket_type s, const sockaddr& addr,
               sock_base::stype type = sock_base::sock_stream,
               const timespec *timeout = 0 )
      {
        basic_iostream<charT,traits>::clear();
        if ( _sb.open( s, addr, type, timeout ) == 0 ) {
          basic_ios<charT,traits>::setstate( ios_base::failbit | ios_base::badbit );
        }
      }

    void open( sock_base::socket_type s,
               sock_base::stype type = sock_base::sock_stream,
               const timespec *timeout = 0 )
      {
        basic_iostream<charT,traits>::clear();
        if ( _sb.open( s, type, timeout ) == 0 ) {
          basic_ios<charT,traits>::setstate( ios_base::failbit | ios_base::badbit );
        }
      }

    void attach( sock_base::socket_type s, const sockaddr& addr,
                 sock_base::stype type = sock_base::sock_stream,
                 const timespec *timeout = 0 )
      {
        basic_iostream<charT,traits>::clear();
        if ( _sb.attach( s, addr, type, timeout ) == 0 ) {
          basic_ios<charT,traits>::setstate( ios_base::failbit | ios_base::badbit );
        }
      }

    void attach( sock_base::socket_type s,
                 sock_base::stype type = sock_base::sock_stream,
                 const timespec *timeout = 0 )
      {
        basic_iostream<charT,traits>::clear();
        if ( _sb.attach( s, type, timeout ) == 0 ) {
          basic_ios<charT,traits>::setstate( ios_base::failbit | ios_base::badbit );
        }
      }

    void close()
      {
        if ( _sb.is_open() ) {
          if ( _sb.close() == 0 ) {
            basic_ios<charT,traits>::setstate( ios_base::failbit );
          } else {
            basic_iostream<charT,traits>::clear();
          }
        }
      }

   void setoptions( sock_base::so_t optname, bool on_off = true,
                    int __v = 0 );

  private:
    basic_sockbuf<charT,traits,_Alloc> _sb;
};

typedef basic_sockbuf<char,char_traits<char>,allocator<char> >        sockbuf;
typedef basic_sockbuf<wchar_t,char_traits<wchar_t>,allocator<wchar_t> >  wsockbuf;
typedef basic_sockstream<char,char_traits<char>,allocator<char> >     sockstream;
typedef basic_sockstream<wchar_t,char_traits<wchar_t>,allocator<wchar_t> > wsockstream;

#ifdef STLPORT
_STLP_END_NAMESPACE
#else
} // namespace std
#endif

#ifndef __STL_LINK_TIME_INSTANTIATION
#include <sockios/sockstream.cc>
#endif

#endif // __SOCKSTREAM__
