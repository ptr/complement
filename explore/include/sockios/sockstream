// -*- C++ -*- Time-stamp: <05/12/21 17:29:39 ptr>

/*
 * Copyright (c) 1997-1999, 2002, 2003, 2005
 * Petr Ovtchenkov
 *
 * Portion Copyright (c) 1999-2001
 * Parallel Graphics Ltd.
 *
 * Licensed under the Academic Free License Version 2.1
 *
 * This material is provided "as is", with absolutely no warranty expressed
 * or implied. Any use is at your own risk.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.
 */

#ifndef __SOCKSTREAM__
#define __SOCKSTREAM__

#ifndef __config_feature_h
#include <config/feature.h>
#endif

#ifdef __FIT_NONREENTRANT
extern "C" int x_getaddrinfo(const char *, const char *, const struct addrinfo *, struct addrinfo **);
extern "C" void x_freeaddrinfo( struct addrinfo * );
#endif

#include <netdb.h>
#include <netinet/in.h>
#include <arpa/nameser.h>
#include <resolv.h>

#include <iosfwd>
#include <ios>
#include <streambuf>
#include <iostream>
#include <string>

#ifdef WIN32
#  include <winsock2.h>
#else // WIN32
#  include <unistd.h>
#  include <sys/types.h>
#  if defined(__hpux) && !defined(_INCLUDE_XOPEN_SOURCE_EXTENDED)
#    define _INCLUDE_XOPEN_SOURCE_EXTENDED
#  endif
#  include <sys/socket.h>
#  if !defined(__UCLIBC__) && !defined(__FreeBSD__) && !defined(__OpenBSD__) && !defined(__NetBSD__)
#   include <stropts.h>
#  endif
#  ifdef __sun
#    include <sys/conf.h>
#  endif
#  include <netinet/in.h>
#  include <arpa/inet.h>
#  include <netdb.h>
#  ifdef __hpux
// #    ifndef socklen_t // HP-UX 10.01
// typedef int socklen_t;
// #    endif
#  endif
#  include <cerrno>
#endif // !WIN32

_STLP_BEGIN_NAMESPACE

in_addr findhost( const char *hostname ) throw( std::domain_error );
std::string hostname( unsigned long inet_addr );
std::string hostname();

int service( const char *name, const char *proto ) throw( std::domain_error );
std::string service( int port, const char *proto ) throw( std::domain_error );

/*
 * Expected host name, return (via back insert iterator)
 * all IPs (in_addr) for specified host name; nothing will be added in case of
 * failure.
 */
template <class BackInsertIterator>
void gethostaddr( const char *hostname, BackInsertIterator bi )
{
  int _errno = 0;

#ifndef __FIT_GETHOSTBYADDR
  hostent _host;
#  ifndef __hpux
  char tmpbuf[4096];
#  else // __hpux
  hostent_data tmpbuf;
#  endif // __hpux
#  ifdef __linux
  hostent *host = 0;
  gethostbyname_r( hostname, &_host, tmpbuf, 4096, &host, &_errno );
#  elif defined(__hpux)
  _errno = gethostbyname_r( hostname, &_host, &tmpbuf );
  hostent *host = &_host;
#  elif defined(__sun)
  hostent *host = gethostbyname_r( hostname, &_host, tmpbuf, 4096, &_errno );
#  else // !__linux !__hpux !__sun
#    error "Check port of gethostbyname_r"
#  endif // __linux __hpux __sun
#else // __FIT_GETHOSTBYADDR
  hostent *host = gethostbyname( hostname );
#  ifdef WIN32
  if ( host == 0 ) {
    _errno = WSAGetLastError();

    // specific to Wins only:
    // cool M$ can't resolve IP address in gethostbyname, try once more
    // via inet_addr() and gethostbyaddr()
    // Returned _errno depend upon WinSock version, and applied patches,
    // with some of it even gethostbyname may be succeed.
    if ( _errno == WSAHOST_NOT_FOUND || _errno == WSATRY_AGAIN ) {
      unsigned long ipaddr = ::inet_addr( hostname );
      if ( ipaddr != INADDR_NONE ) {
        host = gethostbyaddr( (const char *)&ipaddr, sizeof(ipaddr), AF_INET );
        if ( host != 0 ) { // Oh, that's was IP indeed...
          memcpy( (char *)&inet, (char *)host->h_addr, host->h_length );
          WSASetLastError( 0 ); // clear error
          _errno = 0;
        } else {
          _errno = WSAGetLastError();
        }
      }
    }
  }
#  endif // WIN32
#endif // __FIT_GETHOSTBYADDR

  if ( host != 0 && host->h_length == sizeof(in_addr) ) {
    for ( char **_inet = host->h_addr_list; *_inet != 0; ++_inet ) {
      *bi++ = *((in_addr *)*_inet);
    }
  }
}

/*
 * Expected host name, return (via back insert iterator)
 * all sockaddr for specified host name; nothing will be added in case of
 * failure. (Alternative implementation to gethostaddr above; it most
 * useful on systems without reentrant gethostbyname_r, but that has
 * reentrant getaddrinfo, like FreeBSD >= 5.3)
 */
template <class BackInsertIterator>
void gethostaddr2( const char *hostname, BackInsertIterator bi )
{
  // addrinfo hints;
  addrinfo *hosts_list = 0;

#ifndef __FIT_NONREENTRANT
  int _errno = getaddrinfo( hostname, 0, 0, &hosts_list );
#else
  int _errno = x_getaddrinfo( hostname, 0, 0, &hosts_list );
#endif
  if ( _errno == 0 ) {
    addrinfo *host = hosts_list;
    if ( host != 0 && host->ai_addr != 0 ) {
      while ( host != 0 ) {
        // *bi++ = ((in_addr *)host->ai_addr->sa_data)->s_addr;
        *bi++ = *host->ai_addr;
        host = host->ai_next;
      }
    }
  }
  if ( hosts_list != 0 ) {
#ifndef __FIT_NONREENTRANT
    freeaddrinfo( hosts_list );
#else
    x_freeaddrinfo( hosts_list );
#endif
  }
}


class sock_base
{
  public:
    typedef unsigned long shutdownflg;
#ifdef __unix
    typedef int           socket_type;
#endif
#ifdef WIN32
    typedef SOCKET        socket_type;
#endif

    enum stype {
      sock_stream	= SOCK_STREAM,    // stream socket
      sock_dgram	= SOCK_DGRAM,     // datagram socket
      sock_raw	        = SOCK_RAW,       // raw-protocol interface
      sock_rdm	        = SOCK_RDM,       // reliably-delivered message
      sock_seqpacket    = SOCK_SEQPACKET  // sequenced packet stream
    };

    enum protocol {
      local,                              // local to host (pipes, portals)
      inet                                // internetwork: UDP, TCP, etc.
    };

    // Option flags per-socket.
    enum so_t {
      so_debug	        = SO_DEBUG,       // turn on debugging info recording
#ifndef __linux
      so_acceptconn     = SO_ACCEPTCONN,  // socket has had listen()
#endif
      so_reuseaddr	= SO_REUSEADDR,   // allow local address reuse
      so_keepalive	= SO_KEEPALIVE,   // keep connections alive
      so_dontroute	= SO_DONTROUTE,   // just use interface addresses
      so_broadcast	= SO_BROADCAST,   // permit sending of broadcast msgs
#ifndef __linux
      so_useloopback    = SO_USELOOPBACK, // bypass hardware when possible
#endif
      so_linger	        = SO_LINGER,      // linger on close if data present
      so_oobinline	= SO_OOBINLINE,   // leave received OOB data in line
      // Additional options, not kept in so_options.
      so_sndbuf		= SO_SNDBUF,      // send buffer size
      so_rcvbuf		= SO_RCVBUF,      // receive buffer size
      so_sndlowat       = SO_SNDLOWAT,    // send low-water mark
      so_rcvlowat       = SO_RCVLOWAT,    // receive low-water mark
      so_sndtimeo       = SO_SNDTIMEO,    // send timeout
      so_rcvtimeo       = SO_RCVTIMEO,    // receive timeout
      so_error		= SO_ERROR,       // get error status and clear
      so_type		= SO_TYPE         // get socket type
#ifdef __sun // indeed HP-UX 11.00 also has it, but 10.01 not
                                 ,
      so_prototype      = SO_PROTOTYPE    // get/set protocol type
#endif
    };

    // Level number for (get/set)sockopt() to apply to socket itself.
//    enum _level {
//      sol_socket        = SOL_SOCKET
//    };

    enum shutdownflags {
      stop_in  = 0x1,
      stop_out = 0x2
    };

#ifdef WIN32
    class Init
    {
        // sometimes I need Init outside sock_base...
        // private:
      public:
	__FIT_DECLSPEC Init();
	__FIT_DECLSPEC ~Init();

        friend class sock_base;
    };

  protected:
    __FIT_DECLSPEC sock_base();
    __FIT_DECLSPEC ~sock_base();
#endif
};

template<class charT, class traits, class _Alloc>
class basic_sockbuf :
	public basic_streambuf<charT, traits>
{
  public:
    typedef basic_ios<charT, traits>       ios_type;
    typedef basic_sockbuf<charT, traits, _Alloc> sockbuf_type;
    typedef typename traits::state_type    state_t;
#ifdef WIN32
    typedef u_short                        family_type;
#else
#  ifdef sa_family_t
    typedef sa_family_t                    family_type;
#  else // HP-UX 10.01
    typedef unsigned short                 family_type;
#  endif
#endif
    
  public:
  /* Inherited from basic_streambuf : */
    typedef charT                      char_type;
    typedef typename traits::int_type  int_type;
    typedef typename traits::pos_type  pos_type;
    typedef typename traits::off_type  off_type;
    typedef traits                     traits_type;
  /*  */
      
    basic_sockbuf() :
        _fd( -1 ),
        _mode( 0 ), _bbuf(0), _ebuf(0), _allocated( true )
      // , _doclose( true )
      {
        _M_lock_w._M_initialize();
#ifdef __FIT_POLL
        _timeout = -1;
#endif
#ifdef __FIT_SELECT
        _timeout_ref = 0;
#endif
      }
    basic_sockbuf( const char *hostname, int port,
                   sock_base::stype type = sock_base::sock_stream,
                   sock_base::protocol prot = sock_base::inet,
                   const timespec *timeout = 0 ) :
        _fd( -1 ),
        _mode( 0 ), _bbuf(0), _ebuf(0), _allocated( true )
      // , _doclose( true )
      {
        _M_lock_w._M_initialize();
        open( hostname, port, type, prot, timeout );
      }
    virtual ~basic_sockbuf()
      {
        close();
        _M_deallocate_block();
        _M_lock_w._M_destroy();
      }

    bool is_open() const
      { return _fd != -1; }

    sockbuf_type *open( const char *hostname, int port,
                        sock_base::stype type = sock_base::sock_stream,
                        sock_base::protocol prot = sock_base::inet,
                        const timespec *timeout = 0 );

    sockbuf_type *open( sock_base::socket_type s,
                        sock_base::stype t = sock_base::sock_stream,
                        const timespec *timeout = 0 );

    sockbuf_type *open( sock_base::socket_type s, const sockaddr& addr,
                        sock_base::stype t = sock_base::sock_stream,
                        const timespec *timeout = 0 );

    sockbuf_type *attach( sock_base::socket_type s,
                          sock_base::stype t = sock_base::sock_stream,
                          const timespec *timeout = 0 );

    sockbuf_type *attach( sock_base::socket_type s, const sockaddr& addr,
                          sock_base::stype t = sock_base::sock_stream,
                          const timespec *timeout = 0 );

    sockbuf_type *close();
    void shutdown( sock_base::shutdownflg dir );

    sock_base::socket_type fd() const { return _fd;}

    family_type family() const
      { return /* is_open() ? */ _address.any.sa_family /* : 0 */; }

    int port() const
      { return /* is_open() && */ _address.any.sa_family == AF_INET ?
          _address.inet.sin_port : 0; }

    unsigned long inet_addr() const
      { return /* is_open() && */ _address.any.sa_family == AF_INET ?
          _address.inet.sin_addr.s_addr : 0; }

   sock_base::stype stype() const
      { return _type; }

    // const string& hostname() const
    // { return _hostname; }

  protected:
    // bool findhost( const char *hostname );

    virtual streamsize showmanyc()
      { return this->egptr() - this->gptr(); }

    virtual int_type underflow();
    virtual int_type overflow( int_type c = traits::eof() );
    virtual int_type pbackfail( int_type c = traits::eof() )
      {
        if ( !is_open() )
          return traits::eof();

        if ( this->gptr() <= this->eback() ) {
          return traits::eof();
        }

        this->gbump(-1);
        if ( !traits::eq_int_type(c,traits::eof()) ) {
          *this->gptr() = traits::to_char_type(c);
          return c;
        }

        return traits::not_eof(c);
      }

    // Buffer managment and positioning:
    virtual basic_streambuf<charT, traits> *setbuf(char_type *s, streamsize n )
      {
        if ( s != 0 && n != 0 ) {
          _M_deallocate_block();
          _allocated = false;
          _bbuf = s;
          _ebuf = s + n;
        }
        return this;
      }

    virtual int sync()
      {
        if ( !is_open() ) {
          return -1;
        }

        long count = this->pptr() - this->pbase();
        if ( count ) {
          // _STLP_ASSERT( this->pbase() != 0 );
          if ( (this->*_xwrite)( this->pbase(), sizeof(charT) * count ) != count * sizeof(charT) )
            return -1;
          setp( this->pbase(), this->epptr() ); // require: set pptr
        }

        return 0;
      }

    virtual streamsize xsputn(const char_type *s, streamsize n);

  public:
    _STLP_mutex_base _M_lock_w; // lock for writing
    // _STL_mutex_base _M_lock; used for read lock
  private: // Helper functions
    charT* _bbuf;
    charT* _ebuf;
    bool _allocated; // true, if _bbuf should be deallocated
#ifdef __FIT_POLL
    int  _timeout; // milliseconds
#endif
#ifdef __FIT_SELECT
    struct timeval _timeout;
    struct timeval *_timeout_ref;
#endif

    // Precondition: 0 < __n <= max_size().
    charT* _M_allocate( size_t __n ) { return _M_data_allocator.allocate(__n); }
    void _M_deallocate( charT* __p, size_t __n )
      { if (__p) _M_data_allocator.deallocate(__p, __n); }

    void _M_allocate_block(size_t __n)
      {
        if ( _allocated ) {
          if ( __n <= max_size() ) {
            _bbuf = _M_allocate(__n);
            _ebuf = _bbuf + __n;
            // _STLP_ASSERT( __n > 0 ? _bbuf != 0 : _bbuf == 0 );
          } else
            this->_M_throw_length_error();
        }
      }

    void _M_deallocate_block()
      { if ( _allocated ) _M_deallocate(_bbuf, _ebuf - _bbuf); }
  
    size_t max_size() const { return (size_t(-1) / sizeof(charT)) - 1; }

    void _M_throw_length_error() const
      { _STLP_THROW(length_error("basic_sockbuf")); }

    typedef typename _Alloc_traits<charT, _Alloc>::allocator_type allocator_type;
    /* typedef __allocator<charT, _Alloc> _Alloc_type; */

    /* _Alloc_type */ allocator_type _M_data_allocator;    

  private:
    typedef basic_sockbuf<charT,traits,_Alloc> _Self_type;
    // int __rdsync();
    int (basic_sockbuf<charT,traits,_Alloc>::*_xwrite)( const void *, size_t );
    int (basic_sockbuf<charT,traits,_Alloc>::*_xread)( void *, size_t );
    int write( const void *buf, size_t n )
#ifndef WIN32
      { return ::write( _fd, buf, n ); }
#else
      { return ::send( _fd, (const char *)buf, n, 0 ); }
#endif
    int send( const void *buf, size_t n )
#ifdef WIN32
      { return ::send( _fd, (const char *)buf, n, 0 ); }
#else
      { return ::send( _fd, buf, n, 0 ); }
#endif
    int sendto( const void *buf, size_t n )
#ifdef WIN32
      { return ::sendto( _fd, (const char *)buf, n, 0, &_address.any, sizeof( sockaddr_in ) ); }
#else
      { return ::sendto( _fd, buf, n, 0, &_address.any, sizeof( sockaddr_in ) ); }
#endif

    int read( void *buf, size_t n )
#ifdef WIN32
      { return ::recv( _fd, (char *)buf, n, 0  ); }
#else
      { return ::read( _fd, buf, n ); }
#endif
    int recv( void *buf, size_t n )
#ifdef WIN32
      { return ::recv( _fd, (char *)buf, n, 0  ); }
#else
      { return ::recv( _fd, buf, n, 0 ); }
#endif
    int recvfrom( void *buf, size_t n );
    void __hostname();

    sock_base::socket_type _fd;
    union {
        sockaddr_in inet;
        sockaddr    any;
    } _address;

    ios_base::openmode  _mode;
    int                 _errno;
    sock_base::stype    _type;
    // bool                _doclose;
    // if open, and connected, other side hostname,
    // otherwise undefined:
    // string              _hostname; 
};

template <class charT, class traits, class _Alloc>
class basic_sockstream :
	public sock_base,
	public basic_iostream<charT,traits>
{
  public:
    /* Inherited from basic_iostream
    typedef charT                     char_type;
    typedef typename traits::int_type int_type;
    typedef typename traits::pos_type pos_type;
    typedef typename traits::off_type off_type;
    */
    basic_sockstream() :
        sock_base(),
        basic_iostream<charT,traits>( 0 )
	  { basic_ios<charT,traits>::init(&_sb); }
    basic_sockstream( const char *hostname, int port,
                      sock_base::stype type = sock_base::sock_stream,
                      sock_base::protocol pro = sock_base::inet,
                      const timespec *timeout = 0 ) :
        sock_base(),
        basic_iostream<charT,traits>( 0 )
      {
        basic_ios<charT,traits>::init(&_sb);
        basic_iostream<charT,traits>::clear();
        if ( _sb.open( hostname, port, type, pro, timeout ) == 0 ) {
          basic_ios<charT,traits>::setstate( ios_base::failbit | ios_base::badbit );
        }
      }

    basic_sockstream( sock_base::socket_type s, const sockaddr& addr,
                      sock_base::stype type = sock_base::sock_stream,
                      const timespec *timeout = 0 ) :
        sock_base(),
        basic_iostream<charT,traits>( 0 )
      {
        basic_ios<charT,traits>::init(&_sb);
        basic_iostream<charT,traits>::clear();
        if ( _sb.open( s, addr, type, timeout ) == 0 ) {
          basic_ios<charT,traits>::setstate( ios_base::failbit | ios_base::badbit );
        }
      }

    basic_sockstream( sock_base::socket_type s,
                      sock_base::stype type = sock_base::sock_stream,
                      const timespec *timeout = 0 ) :
        sock_base(),
        basic_iostream<charT,traits>( 0 )
      {
        basic_ios<charT,traits>::init(&_sb);
        basic_iostream<charT,traits>::clear();
        if ( _sb.open( s, type, timeout ) == 0 ) {
          basic_ios<charT,traits>::setstate( ios_base::failbit | ios_base::badbit );
        }
      }

    basic_sockbuf<charT,traits,_Alloc>* rdbuf() const
      { return const_cast<basic_sockbuf<charT,traits,_Alloc>*>(&_sb); }
    bool is_open() const
      { return _sb.is_open(); }
    void open( const char *hostname, int port,
               sock_base::stype type = sock_base::sock_stream,
               sock_base::protocol pro = sock_base::inet,
               const timespec *timeout = 0 )
      {
        basic_iostream<charT,traits>::clear();
        if ( _sb.open( hostname, port, type, pro, timeout ) == 0 ) {
          basic_ios<charT,traits>::setstate( ios_base::failbit | ios_base::badbit );
        }
      }

    // only for sock_stream : inet now!
    void open( sock_base::socket_type s, const sockaddr& addr,
               sock_base::stype type = sock_base::sock_stream,
               const timespec *timeout = 0 )
      {
        basic_iostream<charT,traits>::clear();
        if ( _sb.open( s, addr, type, timeout ) == 0 ) {
          basic_ios<charT,traits>::setstate( ios_base::failbit | ios_base::badbit );
        }
      }

    void open( sock_base::socket_type s,
               sock_base::stype type = sock_base::sock_stream,
               const timespec *timeout = 0 )
      {
        basic_iostream<charT,traits>::clear();
        if ( _sb.open( s, type, timeout ) == 0 ) {
          basic_ios<charT,traits>::setstate( ios_base::failbit | ios_base::badbit );
        }
      }

    void attach( sock_base::socket_type s, const sockaddr& addr,
                 sock_base::stype type = sock_base::sock_stream,
                 const timespec *timeout = 0 )
      {
        basic_iostream<charT,traits>::clear();
        if ( _sb.attach( s, addr, type, timeout ) == 0 ) {
          basic_ios<charT,traits>::setstate( ios_base::failbit | ios_base::badbit );
        }
      }

    void attach( sock_base::socket_type s,
                 sock_base::stype type = sock_base::sock_stream,
                 const timespec *timeout = 0 )
      {
        basic_iostream<charT,traits>::clear();
        if ( _sb.attach( s, type, timeout ) == 0 ) {
          basic_ios<charT,traits>::setstate( ios_base::failbit | ios_base::badbit );
        }
      }

    void close()
      {
        if ( _sb.is_open() ) {
          if ( _sb.close() == 0 ) {
            basic_ios<charT,traits>::setstate( ios_base::failbit );
          } else {
            basic_iostream<charT,traits>::clear();
          }
        }
      }

   void setoptions( sock_base::so_t optname, bool on_off = true,
                    int __v = 0 );

  private:
    basic_sockbuf<charT,traits,_Alloc> _sb;
};

typedef basic_sockbuf<char,char_traits<char>,allocator<char> >        sockbuf;
typedef basic_sockbuf<wchar_t,char_traits<wchar_t>,allocator<wchar_t> >  wsockbuf;
typedef basic_sockstream<char,char_traits<char>,allocator<char> >     sockstream;
typedef basic_sockstream<wchar_t,char_traits<wchar_t>,allocator<wchar_t> > wsockstream;

_STLP_END_NAMESPACE

#ifndef __STL_LINK_TIME_INSTANTIATION
#include <sockios/sockstream.cc>
#endif

#endif // __SOCKSTREAM__
