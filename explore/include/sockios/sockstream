// -*- C++ -*- Time-stamp: <02/07/13 20:46:31 ptr>

/*
 *
 * Copyright (c) 1997-1999, 2002
 * Petr Ovtchenkov
 *
 * Copyright (c) 1999-2001
 * Parallel Graphics Ltd.
 *
 * This material is provided "as is", with absolutely no warranty expressed
 * or implied. Any use is at your own risk.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.
 */

#ifndef __SOCKSTREAM__
#define __SOCKSTREAM__

#ifdef __unix
#  ifdef __HP_aCC
#pragma VERSIONID "@(#)$Id$"
#  else
#pragma ident "@(#)$Id$"
#  endif
#endif

#ifndef __config_feature_h
#include <config/feature.h>
#endif

#include <iosfwd>
#include <ios>
#include <streambuf>
#include <iostream>
#include <string>

#ifdef WIN32
#  include <winsock.h>
#else // WIN32
#  include <unistd.h>
#  include <sys/types.h>
#  if defined(__hpux) && !defined(_INCLUDE_XOPEN_SOURCE_EXTENDED)
#    define _INCLUDE_XOPEN_SOURCE_EXTENDED
#  endif
#  include <sys/socket.h>
#  include <stropts.h>
#  ifdef __sun
#    include <sys/conf.h>
#  endif
#  include <netinet/in.h>
#  include <arpa/inet.h>
#  include <netdb.h>
#  ifdef __hpux
// #    ifndef socklen_t // HP-UX 10.01
// typedef int socklen_t;
// #    endif
#  endif
#  include <cerrno>
#endif // !WIN32

_STLP_BEGIN_NAMESPACE

in_addr findhost( const char *hostname ) throw( std::domain_error );
std::string hostname( unsigned long inet_addr );

int service( const char *name, const char *proto ) throw( std::domain_error );
std::string service( int port, const char *proto ) throw( std::domain_error );


class sock_base
{
  public:
    typedef unsigned long shutdownflg;
#ifdef __unix
    typedef int           socket_type;
#endif
#ifdef WIN32
    typedef SOCKET        socket_type;
#endif

    enum stype {
      sock_stream	= SOCK_STREAM,    // stream socket
      sock_dgram	= SOCK_DGRAM,     // datagram socket
      sock_raw	        = SOCK_RAW,       // raw-protocol interface
      sock_rdm	        = SOCK_RDM,       // reliably-delivered message
      sock_seqpacket    = SOCK_SEQPACKET  // sequenced packet stream
    };

    enum protocol {
      local,                              // local to host (pipes, portals)
      inet                                // internetwork: UDP, TCP, etc.
    };

    // Option flags per-socket.
    enum so_t {
      so_debug	        = SO_DEBUG,       // turn on debugging info recording
#ifndef __linux
      so_acceptconn     = SO_ACCEPTCONN,  // socket has had listen()
#endif
      so_reuseaddr	= SO_REUSEADDR,   // allow local address reuse
      so_keepalive	= SO_KEEPALIVE,   // keep connections alive
      so_dontroute	= SO_DONTROUTE,   // just use interface addresses
      so_broadcast	= SO_BROADCAST,   // permit sending of broadcast msgs
#ifndef __linux
      so_useloopback    = SO_USELOOPBACK, // bypass hardware when possible
#endif
      so_linger	        = SO_LINGER,      // linger on close if data present
      so_oobinline	= SO_OOBINLINE,   // leave received OOB data in line
      // Additional options, not kept in so_options.
      so_sndbuf		= SO_SNDBUF,      // send buffer size
      so_rcvbuf		= SO_RCVBUF,      // receive buffer size
      so_sndlowat       = SO_SNDLOWAT,    // send low-water mark
      so_rcvlowat       = SO_RCVLOWAT,    // receive low-water mark
      so_sndtimeo       = SO_SNDTIMEO,    // send timeout
      so_rcvtimeo       = SO_RCVTIMEO,    // receive timeout
      so_error		= SO_ERROR,       // get error status and clear
      so_type		= SO_TYPE         // get socket type
#ifdef __sun // indeed HP-UX 11.00 also has it, but 10.01 not
                                 ,
      so_prototype      = SO_PROTOTYPE    // get/set protocol type
#endif
    };

    // Level number for (get/set)sockopt() to apply to socket itself.
//    enum _level {
//      sol_socket        = SOL_SOCKET
//    };

    enum shutdownflags {
      stop_in  = 0x1,
      stop_out = 0x2
    };

#ifdef WIN32
    class Init
    {
        // sometimes I need Init outside sock_base...
        // private:
      public:
	__FIT_DECLSPEC Init();
	__FIT_DECLSPEC ~Init();

        friend class sock_base;
    };

  protected:
    __FIT_DECLSPEC sock_base();
    __FIT_DECLSPEC ~sock_base();
#endif
};

template<class charT, class traits, class _Alloc>
class basic_sockbuf :
	public basic_streambuf<charT, traits>
{
  public:
    typedef basic_ios<charT, traits>       ios_type;
    typedef typename traits::state_type    state_t;
#ifdef WIN32
    typedef u_short                        family_type;
#else
#  ifdef sa_family_t
    typedef sa_family_t                    family_type;
#  else // HP-UX 10.01
    typedef unsigned short                 family_type;
#  endif
#endif
    
  public:
  /* Inherited from basic_streambuf : */
    typedef charT                      char_type;
    typedef typename traits::int_type  int_type;
    typedef typename traits::pos_type  pos_type;
    typedef typename traits::off_type  off_type;
    typedef traits                     traits_type;
  /*  */
      
    basic_sockbuf() :
      _fd( -1 ),
      _mode( 0 ), _bbuf(0), _ebuf(0), _allocated( true )   
      {
        _M_lock_w._M_initialize();
      }
    basic_sockbuf( const char *hostname, int port,
		   sock_base::stype type = sock_base::sock_stream,
		   sock_base::protocol prot = sock_base::inet ) :
      _fd( -1 ),
      _mode( 0 ), _bbuf(0), _ebuf(0), _allocated( true )   
      {
        _M_lock_w._M_initialize();
        open( hostname, port, type, prot );
      }
    virtual ~basic_sockbuf()
      {
        close();
        _M_deallocate_block();
        _M_lock_w._M_destroy();
      }

    bool is_open() const
      { return _fd != -1; }

    basic_sockbuf<charT, traits, _Alloc> *open( const char *hostname, int port,
					sock_base::stype type = sock_base::sock_stream,
					sock_base::protocol prot = sock_base::inet );

    basic_sockbuf<charT, traits, _Alloc> *open( sock_base::socket_type s, const sockaddr& addr,
					sock_base::stype t = sock_base::sock_stream );

    basic_sockbuf<charT, traits, _Alloc> *close();
    void shutdown( sock_base::shutdownflg dir );

    sock_base::socket_type fd() const { return _fd;}

    family_type family() const
      { return /* is_open() ? */ _address.any.sa_family /* : 0 */; }
    int port() const
      { return /* is_open() && */ _address.any.sa_family == AF_INET ?
	  _address.inet.sin_port : 0; }
    unsigned long inet_addr() const
      { return /* is_open() && */ _address.any.sa_family == AF_INET ?
	  _address.inet.sin_addr.s_addr : 0; }
   sock_base::stype stype() const
     { return _type; }

    // const string& hostname() const
    // { return _hostname; }

  protected:
    // bool findhost( const char *hostname );

    virtual streamsize showmanyc()
      { return this->egptr() - this->gptr(); }

    virtual int_type underflow();
    virtual int_type overflow( int_type c = traits::eof() );
    virtual int_type pbackfail( int_type c = traits::eof() )
      {
	if ( !is_open() )
	  return traits::eof();

	if ( this->gptr() <= this->eback() ) {
	  return traits::eof();
	}

	this->gbump(-1);
	if ( !traits::eq_int_type(c,traits::eof()) ) {
	  *this->gptr() = traits::to_char_type(c);
	  return c;
	}

	return traits::not_eof(c);
      }

    // Buffer managment and positioning:
    virtual basic_streambuf<charT, traits> *setbuf(char_type *s, streamsize n )
      {
	if ( s != 0 && n != 0 ) {
	  _M_deallocate_block();
	  _allocated = false;
	  _bbuf = s;
	  _ebuf = s + n;
	}
	return this;
      }

    virtual int sync()
      {
	if ( !is_open() ) {
	  return -1;
	}

	long count = this->pptr() - this->pbase();
	if ( count ) {
	  _STLP_ASSERT( this->pbase() != 0 );
	  if ( (this->*_xwrite)( this->pbase(), sizeof(charT) * count ) != count * sizeof(charT) )
	    return -1;
	  setp( this->pbase(), this->epptr() ); // require: set pptr
	}

	return 0;
      }

    virtual streamsize xsputn(const char_type *s, streamsize n);

  public:
    _STLP_mutex_base _M_lock_w; // lock for writing
    // _STL_mutex_base _M_lock; used for read lock
  private: // Helper functions
    charT* _bbuf;
    charT* _ebuf;
    bool _allocated; // true, if _bbuf should be deallocated

    // Precondition: 0 < __n <= max_size().
    charT* _M_allocate( size_t __n ) { return _M_data_allocator.allocate(__n); }
    void _M_deallocate( charT* __p, size_t __n )
      { if (__p) _M_data_allocator.deallocate(__p, __n); }

    void _M_allocate_block(size_t __n)
      {
	if ( _allocated ) {
	  if ( __n <= max_size() ) {
	    _bbuf = _M_allocate(__n);
	    _ebuf = _bbuf + __n;
	    _STLP_ASSERT( __n > 0 ? _bbuf != 0 : _bbuf == 0 );
	  } else
	    this->_M_throw_length_error();
	}
      }

    void _M_deallocate_block()
      { if ( _allocated ) _M_deallocate(_bbuf, _ebuf - _bbuf); }
  
    size_t max_size() const { return (size_t(-1) / sizeof(charT)) - 1; }

    void _M_throw_length_error() const
      { _STLP_THROW(length_error("basic_sockbuf")); }

    typedef typename _Alloc_traits<charT, _Alloc>::allocator_type allocator_type;
    /* typedef __allocator<charT, _Alloc> _Alloc_type; */

    /* _Alloc_type */ allocator_type _M_data_allocator;    

  private:
    typedef basic_sockbuf<charT,traits,_Alloc> _Self_type;
    // int __rdsync();
    int (basic_sockbuf<charT,traits,_Alloc>::*_xwrite)( const void *, size_t );
    int (basic_sockbuf<charT,traits,_Alloc>::*_xread)( void *, size_t );
    int write( const void *buf, size_t n )
#ifndef WIN32
      { return ::write( _fd, buf, n ); }
#else
      { return ::send( _fd, (const char *)buf, n, 0 ); }
#endif
    int send( const void *buf, size_t n )
#ifdef WIN32
      { return ::send( _fd, (const char *)buf, n, 0 ); }
#else
      { return ::send( _fd, buf, n, 0 ); }
#endif
    int sendto( const void *buf, size_t n )
#ifdef WIN32
      { return ::sendto( _fd, (const char *)buf, n, 0, &_address.any, sizeof( sockaddr_in ) ); }
#else
      { return ::sendto( _fd, buf, n, 0, &_address.any, sizeof( sockaddr_in ) ); }
#endif

    int read( void *buf, size_t n )
#ifdef WIN32
      { return ::recv( _fd, (char *)buf, n, 0  ); }
#else
      { return ::read( _fd, buf, n ); }
#endif
    int recv( void *buf, size_t n )
#ifdef WIN32
      { return ::recv( _fd, (char *)buf, n, 0  ); }
#else
      { return ::recv( _fd, buf, n, 0 ); }
#endif
    int recvfrom( void *buf, size_t n );
    void __hostname();

    sock_base::socket_type _fd;
    union {
	sockaddr_in inet;
	sockaddr    any;
    } _address;

    ios_base::openmode  _mode;
    int                 _errno;
    sock_base::stype    _type;
    // if open, and connected, other side hostname,
    // otherwise undefined:
    // string              _hostname; 
};

template <class charT, class traits, class _Alloc>
class basic_sockstream :
	public sock_base,
	public basic_iostream<charT,traits>
{
  public:
    /* Inherited from basic_iostream
    typedef charT                     char_type;
    typedef typename traits::int_type int_type;
    typedef typename traits::pos_type pos_type;
    typedef typename traits::off_type off_type;
    */
    basic_sockstream() :
	sock_base(),
	basic_iostream<charT,traits>( 0 )
	  { basic_ios<charT,traits>::init(&_sb); }
    basic_sockstream( const char *hostname, int port,
                      sock_base::stype type = sock_base::sock_stream,
                      sock_base::protocol pro = sock_base::inet ) :
	sock_base(),
	basic_iostream<charT,traits>( 0 )
      {
        basic_ios<charT,traits>::init(&_sb);
	basic_iostream<charT,traits>::clear();
	if ( _sb.open( hostname, port, type, pro ) == 0 ) {
	  setstate( ios_base::failbit | ios_base::badbit );
	}
      }

    basic_sockstream( sock_base::socket_type s, const sockaddr& addr,
                               sock_base::stype type = sock_base::sock_stream ) :
	sock_base(),
	basic_iostream<charT,traits>( 0 )
      {
        basic_ios<charT,traits>::init(&_sb);
	basic_iostream<charT,traits>::clear();
	if ( _sb.open( s, addr, type ) == 0 ) {
	  setstate( ios_base::failbit | ios_base::badbit );
	}
      }

    basic_sockbuf<charT,traits,_Alloc>* rdbuf() const
      { return const_cast<basic_sockbuf<charT,traits,_Alloc>*>(&_sb); }
    bool is_open() const
      { return _sb.is_open(); }
    void open( const char *hostname, int port,
	       sock_base::stype type = sock_base::sock_stream,
	       sock_base::protocol pro = sock_base::inet )
      {
	basic_iostream<charT,traits>::clear();
	if ( _sb.open( hostname, port, type, pro ) == 0 ) {
	  setstate( ios_base::failbit | ios_base::badbit );
	}
      }

    // only for sock_stream : inet now!
    void open( sock_base::socket_type s, const sockaddr& addr,
	       sock_base::stype type = sock_base::sock_stream )
      {
	basic_iostream<charT,traits>::clear();
	if ( _sb.open( s, addr, type ) == 0 ) {
	  setstate( ios_base::failbit | ios_base::badbit );
	}
      }

    void close()
      {
	if ( _sb.is_open() ) {
	  if ( _sb.close() == 0 ) {
	    setstate( ios_base::failbit );
	  } else {
	    basic_iostream<charT,traits>::clear();
	  }
	}
      }

   void setoptions( sock_base::so_t optname, bool on_off = true,
                    int __v = 0 );

  private:
    basic_sockbuf<charT,traits,_Alloc> _sb;
};

typedef basic_sockbuf<char,char_traits<char>,allocator<char> >        sockbuf;
typedef basic_sockbuf<wchar_t,char_traits<wchar_t>,allocator<wchar_t> >  wsockbuf;
typedef basic_sockstream<char,char_traits<char>,allocator<char> >     sockstream;
typedef basic_sockstream<wchar_t,char_traits<wchar_t>,allocator<wchar_t> > wsockstream;

_STLP_END_NAMESPACE

#ifndef __STL_LINK_TIME_INSTANTIATION
#include <sockios/sockstream.cc>
#endif

#endif // __SOCKSTREAM__
