// -*- C++ -*- Time-stamp: <08/06/09 22:22:05 yeti>

/*
 * Copyright (c) 1997-1999, 2002, 2003, 2005-2008
 * Petr Ovtchenkov
 *
 * Portion Copyright (c) 1999-2001
 * Parallel Graphics Ltd.
 *
 * Licensed under the Academic Free License version 3.0
 *
 */

#ifndef __SOCKIOS_SOCKSTREAM
#define __SOCKIOS_SOCKSTREAM

#ifndef __config_feature_h
#include <config/feature.h>
#endif

#if !defined(__sun) && !defined(_WIN32) // i.e. __linux and __hpux
#include <sys/poll.h> // pollfd
#endif

#include <mt/mutex>
#include <mt/condition_variable>
#include <mt/date_time>
#include <mt/thread>

#include <netdb.h>
#include <netinet/in.h>

#include <iosfwd>
#include <ios>
#include <streambuf>
#include <iostream>
#include <string>
#include <stdexcept>

#ifdef WIN32
#  include <winsock2.h>
#else // WIN32
#  include <unistd.h>
#  include <sys/types.h>
#  if defined(__hpux) && !defined(_INCLUDE_XOPEN_SOURCE_EXTENDED)
#    define _INCLUDE_XOPEN_SOURCE_EXTENDED
#  endif
#  include <sys/socket.h>
#  if !defined(__UCLIBC__) && !defined(__FreeBSD__) && !defined(__OpenBSD__) && !defined(__NetBSD__)
#   include <stropts.h>
#  endif
#  ifdef __sun
#    include <sys/conf.h>
#  endif
#  include <netinet/in.h>
#  include <arpa/inet.h>
#  include <netdb.h>
#  ifdef __hpux
// #    ifndef socklen_t // HP-UX 10.01
// typedef int socklen_t;
// #    endif
#  endif
#  include <cerrno>
#endif // !WIN32

#include <sockios/netinfo.h>

#ifdef STLPORT
_STLP_BEGIN_NAMESPACE
#else
namespace std {
#endif

class sock_base
{
  public:
    typedef unsigned long shutdownflg;
#ifdef __unix
    typedef int           socket_type;
#endif
#ifdef WIN32
    typedef SOCKET        socket_type;
#endif

    enum stype {
      sock_stream	= SOCK_STREAM,    // stream socket
      sock_dgram	= SOCK_DGRAM,     // datagram socket
      sock_raw	        = SOCK_RAW,       // raw-protocol interface
      sock_rdm	        = SOCK_RDM,       // reliably-delivered message
      sock_seqpacket    = SOCK_SEQPACKET  // sequenced packet stream
    };

    enum protocol {
      local,                              // local to host (pipes, portals)
      inet                                // internetwork: UDP, TCP, etc.
    };

    // Option flags per-socket.
    enum so_t {
      so_debug	        = SO_DEBUG,       // turn on debugging info recording
#ifndef __linux
      so_acceptconn     = SO_ACCEPTCONN,  // socket has had listen()
#endif
      so_reuseaddr	= SO_REUSEADDR,   // allow local address reuse
      so_keepalive	= SO_KEEPALIVE,   // keep connections alive
      so_dontroute	= SO_DONTROUTE,   // just use interface addresses
      so_broadcast	= SO_BROADCAST,   // permit sending of broadcast msgs
#ifndef __linux
      so_useloopback    = SO_USELOOPBACK, // bypass hardware when possible
#endif
      so_linger	        = SO_LINGER,      // linger on close if data present
      so_oobinline	= SO_OOBINLINE,   // leave received OOB data in line
      // Additional options, not kept in so_options.
      so_sndbuf		= SO_SNDBUF,      // send buffer size
      so_rcvbuf		= SO_RCVBUF,      // receive buffer size
      so_sndlowat       = SO_SNDLOWAT,    // send low-water mark
      so_rcvlowat       = SO_RCVLOWAT,    // receive low-water mark
      so_sndtimeo       = SO_SNDTIMEO,    // send timeout
      so_rcvtimeo       = SO_RCVTIMEO,    // receive timeout
      so_error		= SO_ERROR,       // get error status and clear
      so_type		= SO_TYPE         // get socket type
#ifdef __sun // indeed HP-UX 11.00 also has it, but 10.01 not
                                 ,
      so_prototype      = SO_PROTOTYPE    // get/set protocol type
#endif
    };

    // Level number for (get/set)sockopt() to apply to socket itself.
//    enum _level {
//      sol_socket        = SOL_SOCKET
//    };

    enum shutdownflags {
      stop_in  = 0x1,
      stop_out = 0x2
    };

#ifdef WIN32
    class Init
    {
        // sometimes I need Init outside sock_base...
        // private:
      public:
	__FIT_DECLSPEC Init();
	__FIT_DECLSPEC ~Init();

        friend class sock_base;
    };

  protected:
    __FIT_DECLSPEC sock_base();
    __FIT_DECLSPEC ~sock_base();
#endif
};

class socket_timeout :
        public std::exception
{
  public:
    socket_timeout()
      { }

    virtual char const *what() throw()
      { return "socket timeout"; }
};

class socket_read_timeout :
        public socket_timeout
{
  public:
    socket_read_timeout()
      { }

    virtual char const *what() throw()
      { return "socket read timeout"; }
};

class socket_write_timeout :
        public socket_timeout
{
  public:
    socket_write_timeout()
      { }

    virtual char const *what() throw()
      { return "socket write timeout"; }
};

namespace detail {
template <class charT, class traits, class _Alloc> class sockmgr;
} // namespace detail

template <class charT, class traits, class _Alloc>
class sock_processor_base;

template<class charT, class traits, class _Alloc>
class basic_socket
{
  protected:
    basic_socket() :
        _fd( -1 ),
        _use_rdtimeout( false ),
        _use_wrtimeout( false ),
        _notify_close( false )
      { new( Init_buf ) Init(); }

    ~basic_socket()
      { ((Init *)Init_buf)->~Init(); }

    bool is_open_unsafe() const
      { return _fd != -1; }
    sock_base::socket_type fd_unsafe() const
      { return _fd; }

    class Init
    {
      public:
        Init()
          { _guard( 1 ); }
        ~Init()
          { _guard( 0 ); }

      private:
        static void _guard( int direction );
        static void __at_fork_prepare();
        static void __at_fork_child();
        static void __at_fork_parent();
        static int _count;
        static bool _at_fork;
    };

    static char Init_buf[];

  public:
#ifdef WIN32
    typedef u_short                        family_type;
#else
#  ifdef sa_family_t
    typedef sa_family_t                    family_type;
#  else // HP-UX 10.01
    typedef unsigned short                 family_type;
#  endif
#endif

    template <class Duration>
    void rdtimeout( const Duration& );
    void rdtimeout() // infinite
      { _use_rdtimeout = false; }

    template <class Duration>
    void wrtimeout( const Duration& );
    void wrtimeout() // infinite
      { _use_wrtimeout = false; }

    sock_base::socket_type fd() const { return _fd;}
    bool is_open() const
      { return _fd != -1; }

    family_type family() const
      { return /* is_open() ? */ _address.any.sa_family /* : 0 */; }

    int port() const
      { return /* is_open() && */ _address.any.sa_family == AF_INET ? _address.inet.sin_port : 0; }

    unsigned long inet_addr() const
      { return /* is_open() && */ _address.any.sa_family == AF_INET ? _address.inet.sin_addr.s_addr : 0; }

    const sockaddr_in& inet_sockaddr() const throw( std::domain_error )
      {
        if ( _address.any.sa_family != AF_INET ) {
          throw domain_error( "socket not belongs to inet type" );
        }
        return /* is_open() && */ _address.inet;
      }

  protected:
    sock_base::socket_type _fd;

    union sockaddr_t {
        sockaddr_in inet;
        sockaddr    any;
    } _address;

    std::tr2::milliseconds _rdtimeout;
    std::tr2::milliseconds _wrtimeout;
    bool _use_rdtimeout;
    bool _use_wrtimeout;
    bool _notify_close;

    static detail::sockmgr<charT,traits,_Alloc>* mgr;
    friend class Init;
};

template<class charT, class traits, class _Alloc>
int basic_socket<charT,traits,_Alloc>::Init::_count = 0;

template<class charT, class traits, class _Alloc>
bool basic_socket<charT,traits,_Alloc>::Init::_at_fork = false;

template<class charT, class traits, class _Alloc>
void basic_socket<charT,traits,_Alloc>::Init::_guard( int direction )
{
  static std::tr2::mutex _init_lock;

  if ( direction ) {
    std::tr2::lock_guard<std::tr2::mutex> lk( _init_lock );
    if ( _count++ == 0 ) {
      basic_socket<charT,traits,_Alloc>::mgr = new detail::sockmgr<charT,traits,_Alloc>();
#ifdef __FIT_PTHREADS
      if ( !_at_fork ) { // call only once
        if ( pthread_atfork( __at_fork_prepare, __at_fork_parent, __at_fork_child ) ) {
          // throw system_error;
        }
        _at_fork = true;
      }
#endif
//       _sock_processor_base::_idx = std::tr2::this_thread::xalloc();
      std::cerr << __FILE__ << ":" << __LINE__ << " new mgr " << std::tr2::getpid() << std::endl;
    }
  } else {
    std::tr2::lock_guard<std::tr2::mutex> lk( _init_lock );
    if ( --_count == 0 ) {
      if ( basic_socket<charT,traits,_Alloc>::mgr == 0 ) {
        std::cerr << __FILE__ << ":" << __LINE__ << " shit happens\n";
      }
      std::cerr << __FILE__ << ":" << __LINE__ << " mgr destroyed " << std::tr2::getpid() << std::endl;
      delete basic_socket<charT,traits,_Alloc>::mgr;
      basic_socket<charT,traits,_Alloc>::mgr = 0;
    }
  }
}

template<class charT, class traits, class _Alloc>
void basic_socket<charT,traits,_Alloc>::Init::__at_fork_prepare()
{
}

template<class charT, class traits, class _Alloc>
void basic_socket<charT,traits,_Alloc>::Init::__at_fork_child()
{
  if ( _count != 0 ) {
    // stop mgr
    _count = 1;
    delete basic_socket<charT,traits,_Alloc>::mgr;
    basic_socket<charT,traits,_Alloc>::mgr = new detail::sockmgr<charT,traits,_Alloc>();
  }
  // _sock_processor_base::_idx =  std::tr2::this_thread::xalloc();
}

template<class charT, class traits, class _Alloc>
void basic_socket<charT,traits,_Alloc>::Init::__at_fork_parent()
{ }

template<class charT, class traits, class _Alloc>
char basic_socket<charT,traits,_Alloc>::Init_buf[128];

template <class charT, class traits, class _Alloc>
detail::sockmgr<charT,traits,_Alloc>* basic_socket<charT,traits,_Alloc>::mgr = 0;

#ifdef STLPORT
_STLP_END_NAMESPACE
#else
} // namespace std
#endif

#include <sockios/sp.h>

#ifdef STLPORT
_STLP_BEGIN_NAMESPACE
#else
namespace std {
#endif

template<class charT, class traits, class _Alloc>
class basic_sockbuf :
	public basic_streambuf<charT, traits>
        // public basic_socket<charT,traits,_Alloc>
{
  private:
    typedef basic_socket<charT,traits,_Alloc> basic_socket_t;

  public:
    typedef basic_ios<charT, traits>       ios_type;
    typedef basic_sockbuf<charT, traits, _Alloc> sockbuf_type;
    typedef typename traits::state_type    state_t;
    typedef typename basic_socket_t::family_type family_type;
    
  public:
  /* Inherited from basic_streambuf : */
    typedef charT                      char_type;
    typedef typename traits::int_type  int_type;
    typedef typename traits::pos_type  pos_type;
    typedef typename traits::off_type  off_type;
    typedef traits                     traits_type;
  /*  */
      
    basic_sockbuf() :
        impl( 0 )
      { }

    basic_sockbuf( const char *hostname, int port,
                   sock_base::stype type = sock_base::sock_stream,
                   sock_base::protocol prot = sock_base::inet ) :
        impl( 0 )
      { open( hostname, port, type, prot ); }

    basic_sockbuf( const in_addr& addr, int port,
                   sock_base::stype type = sock_base::sock_stream,
                   sock_base::protocol prot = sock_base::inet ) :
        impl( 0 )
      { open( addr, type, prot ); }

    virtual ~basic_sockbuf()
      { close(); }

    sockbuf_type *open( const char *hostname, int port,
                        sock_base::stype type = sock_base::sock_stream,
                        sock_base::protocol prot = sock_base::inet );

    sockbuf_type *open( const in_addr& addr, int port,
                        sock_base::stype type = sock_base::sock_stream,
                        sock_base::protocol prot = sock_base::inet )
      { return impl->open( addr, port, type, prot ) ? this : 0; }

    sockbuf_type *open( sock_base::socket_type s,
                        sock_base::stype t = sock_base::sock_stream );

    sockbuf_type *open( sock_base::socket_type s, const sockaddr& addr,
                        sock_base::stype t = sock_base::sock_stream )
      { return impl->open( s, addr, t ) ? this : 0; }

    sockbuf_type *attach( sock_base::socket_type s,
                          sock_base::stype t = sock_base::sock_stream );

    sockbuf_type *attach( sock_base::socket_type s, const sockaddr& addr,
                          sock_base::stype t = sock_base::sock_stream );

    sockbuf_type *close()
      { return impl->close() ? this : 0; }

    void shutdown( sock_base::shutdownflg dir )
      { impl->shutdown( dir ); }

    sock_base::stype stype() const
      { return impl->stype(); }

    template <class Duration>
    void rdtimeout( const Duration& d )
      { impl->rdtimeout( d ); }
    void rdtimeout() // infinite
      { impl->rdtimeout(); }

    template <class Duration>
    void wrtimeout( const Duration& d )
      { impl->wrtimeout( d ); }
    void wrtimeout() // infinite
      { impl->wrtimeout(); }

    sock_base::socket_type fd() const { return impl->fd();}
    bool is_open() const
      { return impl->is_open(); }

    family_type family() const
      { return impl->family(); }

    int port() const
      { return impl->port(); }

    unsigned long inet_addr() const
      { return impl->inet_addr(); }

    const sockaddr_in& inet_sockaddr() const throw( std::domain_error )
      { return impl->inet_sockaddr(); }


  protected:
    virtual streamsize showmanyc()
      { return impl->showmanyc(); }

    virtual int_type underflow()
      { return impl->underflow(); }
    virtual int_type overflow( int_type c = traits::eof() )
      { return impl->overflow(c); }
    virtual int_type pbackfail( int_type c = traits::eof() )
      { return impl->pbackfail( c ); }
    // Buffer managment and positioning:
    virtual basic_streambuf<charT, traits> *setbuf(char_type *s, streamsize n )
      { impl->setbuf( s, n ); return this; }

    virtual int sync()
      { return impl->sync(); }
    virtual streamsize xsputn(const char_type *s, streamsize n)
      { return impl->xsputn( s, n ); }

  private:
    detail::basic_sockbuf_aux<charT,traits,_Alloc> *impl;
};

template <class charT, class traits, class _Alloc>
class basic_sockstream :
	public sock_base,
	public basic_iostream<charT,traits>
{
  public:
    /* Inherited from basic_iostream
    typedef charT                     char_type;
    typedef typename traits::int_type int_type;
    typedef typename traits::pos_type pos_type;
    typedef typename traits::off_type off_type;
    */
    basic_sockstream() :
        sock_base(),
        basic_iostream<charT,traits>( 0 )
	  { basic_ios<charT,traits>::init(&_sb); }
    basic_sockstream( const char *hostname, int port,
                      sock_base::stype type = sock_base::sock_stream,
                      sock_base::protocol pro = sock_base::inet ) :
        sock_base(),
        basic_iostream<charT,traits>( 0 )
      {
        basic_ios<charT,traits>::init(&_sb);
        basic_iostream<charT,traits>::clear();
        if ( _sb.open( hostname, port, type, pro ) == 0 ) {
          basic_ios<charT,traits>::setstate( ios_base::failbit | ios_base::badbit );
        }
      }

    basic_sockstream( const in_addr& addr, int port,
                      sock_base::stype type = sock_base::sock_stream,
                      sock_base::protocol pro = sock_base::inet ) :
        sock_base(),
        basic_iostream<charT,traits>( 0 )
      {
        basic_ios<charT,traits>::init(&_sb);
        basic_iostream<charT,traits>::clear();
        if ( _sb.open( addr, port, type, pro ) == 0 ) {
          basic_ios<charT,traits>::setstate( ios_base::failbit | ios_base::badbit );
        }
      }

    basic_sockstream( sock_base::socket_type s, const sockaddr& addr,
                      sock_base::stype type = sock_base::sock_stream ) :
        sock_base(),
        basic_iostream<charT,traits>( 0 )
      {
        basic_ios<charT,traits>::init(&_sb);
        basic_iostream<charT,traits>::clear();
        if ( _sb.open( s, addr, type ) == 0 ) {
          basic_ios<charT,traits>::setstate( ios_base::failbit | ios_base::badbit );
        }
      }

    basic_sockstream( sock_base::socket_type s,
                      sock_base::stype type = sock_base::sock_stream ) :
        sock_base(),
        basic_iostream<charT,traits>( 0 )
      {
        basic_ios<charT,traits>::init(&_sb);
        basic_iostream<charT,traits>::clear();
        if ( _sb.open( s, type ) == 0 ) {
          basic_ios<charT,traits>::setstate( ios_base::failbit | ios_base::badbit );
        }
      }

    basic_sockbuf<charT,traits,_Alloc>* rdbuf() const
      { return const_cast<basic_sockbuf<charT,traits,_Alloc>*>(&_sb); }

    bool is_open() const
      { return _sb.is_open(); }

    void open( const char *hostname, int port,
               sock_base::stype type = sock_base::sock_stream,
               sock_base::protocol pro = sock_base::inet )
      {
        basic_iostream<charT,traits>::clear();
        if ( _sb.open( hostname, port, type, pro ) == 0 ) {
          basic_ios<charT,traits>::setstate( ios_base::failbit | ios_base::badbit );
        }
      }

    void open( const in_addr& addr, int port,
               sock_base::stype type = sock_base::sock_stream,
               sock_base::protocol pro = sock_base::inet )
      {
        basic_iostream<charT,traits>::clear();
        if ( _sb.open( addr, port, type, pro ) == 0 ) {
          basic_ios<charT,traits>::setstate( ios_base::failbit | ios_base::badbit );
        }
      }

    // only for sock_stream : inet now!
    void open( sock_base::socket_type s, const sockaddr& addr,
               sock_base::stype type = sock_base::sock_stream )
      {
        basic_iostream<charT,traits>::clear();
        if ( _sb.open( s, addr, type ) == 0 ) {
          basic_ios<charT,traits>::setstate( ios_base::failbit | ios_base::badbit );
        }
      }

    void open( sock_base::socket_type s,
               sock_base::stype type = sock_base::sock_stream )
      {
        basic_iostream<charT,traits>::clear();
        if ( _sb.open( s, type ) == 0 ) {
          basic_ios<charT,traits>::setstate( ios_base::failbit | ios_base::badbit );
        }
      }

    void attach( sock_base::socket_type s, const sockaddr& addr,
                 sock_base::stype type = sock_base::sock_stream )
      {
        basic_iostream<charT,traits>::clear();
        if ( _sb.attach( s, addr, type ) == 0 ) {
          basic_ios<charT,traits>::setstate( ios_base::failbit | ios_base::badbit );
        }
      }

    void attach( sock_base::socket_type s,
                 sock_base::stype type = sock_base::sock_stream )
      {
        basic_iostream<charT,traits>::clear();
        if ( _sb.attach( s, type ) == 0 ) {
          basic_ios<charT,traits>::setstate( ios_base::failbit | ios_base::badbit );
        }
      }

    void close()
      {
        if ( _sb.is_open() ) {
          if ( _sb.close() == 0 ) {
            basic_ios<charT,traits>::setstate( ios_base::failbit );
          } else {
            basic_iostream<charT,traits>::clear();
          }
        }
      }

   void setoptions( sock_base::so_t optname, bool on_off = true,
                    int __v = 0 );

  private:
    basic_sockbuf<charT,traits,_Alloc> _sb;
};

typedef basic_sockbuf<char,char_traits<char>,allocator<char> >        sockbuf;
// typedef basic_sockbuf<wchar_t,char_traits<wchar_t>,allocator<wchar_t> >  wsockbuf;
typedef basic_sockstream<char,std::char_traits<char>,std::allocator<char> >     sockstream;
// typedef basic_sockstream<wchar_t,char_traits<wchar_t>,allocator<wchar_t> > wsockstream;

#ifdef STLPORT
_STLP_END_NAMESPACE
#else
} // namespace std
#endif

#ifndef __STL_LINK_TIME_INSTANTIATION
#include <sockios/sockstream.cc>
#endif

#endif // __SOCKIOS_SOCKSTREAM
