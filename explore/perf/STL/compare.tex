% -*- LaTeX -*- Time-stamp: <04/07/28 08:42:39 ptr>

\documentclass[a4paper]{article}

\usepackage[T1]{fontenc}
\usepackage{pslatex}
\usepackage{pstricks}
\usepackage[dvips]{epsfig}
%\usepackage[dvipdf]{graphics}
\usepackage[dvips]{graphics}
\usepackage[american]{babel}

\usepackage{epic}
\usepackage{eepic}
\usepackage{psfig}

\usepackage{listings}

\lstset{language=C++,basicstyle=\small,numbers=left,numberstyle=\tiny,stepnumber=1,numbersep=5pt,stringstyle=\ttfamily,keywordstyle=\ttfamily\bfseries}

\providecommand{\STLport}{{\fontfamily{cmss}\selectfont STLport}}
\providecommand{\libstd}{{\fontfamily{cmtt}\selectfont GNU \mbox{libstd++}}}
\newcommand{\CPP}{\mbox{{C}{+}{+}}}

\title{Comparison of Strings Implementations \\ in \CPP{} language}
\author{Petr Ovtchenkov}

\begin{document}

\maketitle

\begin{abstract}
This article present comparison of 
strings implementation in \STLport{} and \libstd.

This tests also can help to answer on question:
is it strings copy algorithm with constant complexity
better than algorithm with linear complexity?
This comparison is done on the base of STLport strings, ropes
and libstd++ strings.

I expect that this results will help to make decision between
STL implementations as well proper choice of strings implementation.
\end{abstract}

\section{Computers}

In the tests was used following computers and operational envirinments:
\begin{enumerate}
  \item Hands-made machine (assembled by Tersys company) with 2 $1.33$-GHz
        AMD Athlon XP 1500+ processors under Linux (kernel 2.4.20, and 2.4.26, \verb|glibc| 2{.}2{.}5).
\end{enumerate}

\section{Compilers}

For Unix-like systems was used GNU gcc 3{.}3{.}3 and 3{.}4{.}1\footnote{tests \#6 and \#7} % 3{.}1{.}1 and 3{.}2{.}3
with appropriate
\verb|libstd++| libraries (version~3).
% I don't see
% differences in test results between mentioned compiler's versions.
The GNU gcc 3{.}1{.}1 and 3{.}2{.}3 are worse up to $28\%$ (for some
tests).
% in range $0\%$--$6.58\%$.

\section{Time Measure\label{timemeasure}}

Due to ``time'' function has different options and output format on Linux
and other UINIXes, I use program \texttt{time} from
\texttt{complement}\footnote{\texttt{http://complement.sourceforge.net}}
project bundle\footnote{Portability note: system should has \texttt{wait3} function.}.
By the way this function provide high-precision time measure.

\section{Statistic}

The measure accuracy
depends upon program load time, the constant measure drift, common computer load (by other processes) and time measure inaccuracy, the random measure drifts.
To reduce influence as the constant measure drift as the random measure drift, the time of test should not to be too short.

Every experiment repeate $10$~times, to get more-or-less acceptable statistic.
For every series of results I do ordinal statistical manipulation.
Mean time is
\begin{equation}
\bar t = \sum_{i = 1}^{n} t_i,
\end{equation}
where $t_i$ is time measure for test $i$.
Mean square deviation
\begin{equation}
\sigma^2 = \frac{1}{n}\sum_{i = 1}^{n} (t_i - \bar t)^2
\end{equation}
or
\begin{equation}
\sigma^2 = \frac{1}{n}\sum_{i = 1}^{n} t_i^2 - \left(\frac{1}{n}\sum_{i = 1}^{n} t_i\right)^2
\end{equation}
or
\begin{equation}
\sigma^2 = \frac{1}{n} \left(\sum_{i = 1}^{n} t_i^2 - 
                        \frac{1}{n}\left(\sum_{i = 1}^{n} t_i\right)^2\right)\label{incrDev}
\end{equation}
The equation \ref{incrDev} give algorithm of one-pass incremental calculation
both mean value $\bar t$ and it mean square deviation $\sigma^2$.
Small mean square deviation let us to be ensure that results are gain our trust.


\section{The Tests Descriptions\label{TestsDescr}}

\subsection{Add Characters to String\label{incr-string}
(test \#1)}

We have empty string. In the loop we add to this string single
character.
Really this is a test for algorithm
of memory allocation (and moving memory contents to reallocated string).

\lstinputlisting{string/add/str.cc}

\subsection{Search of Substring\label{search-string} (test \#2)}

We have string. In the loop we search three substrings.
The matched substrings are positioned in
the beginning, middle and end of the string. All searches are
successful.

\lstinputlisting{string/find/str.cc}

\subsection{Mixed Operations\label{mixed-string} (test \#3)}

This is a mix of common operations under strings: assignment,
search of substring, replace of substring by another substring,
concatenation of strings.

\lstinputlisting{string/ops/str.cc}

\begin{figure}
  \begin{center}
    \input strings.tex
  \end{center}
  \caption{Comparison of \libstd{} and \STLport{}
           strings implementation. Wall time for tests.
           The implementation of strings in \STLport{} (copy algorithm complexity $O(n)$)
           drammaticaly faster than ones in \libstd{} or ropes in \STLport{}
           (copy algorithm complexity $O(1)$) for tests with strings modification.
           If the test only copy string, the implementation with $O(1)$ complexity
           is better.
           \label{STLport-gpp-strings}}
\end{figure}

\subsection{String copy\label{params-string} (test \#4)}

This test intended to hilight the cost of strings copy (no modification).
Implementations of strings that use algorithms with constant copy time ($O(1)$)
expected to show better results here.


\lstinputlisting{string/params/str.cc}

You can see (fig.~\ref{STLport-gpp-strings}) that \libstd{} show better
results than \STLport{} in this test. The reason is that \libstd{}
use copy algorithm with $O(1)$ complexity: during copy operation
there are no memory allocation occur---two strings refer to the same
memory chunk (like \verb|tmp| and \verb|par| on line~$9$). This test
has three copy operations (lines~$7$, $9$ and $20$).

\subsection{String copy again\label{params-ref-string} (test \#5)}

This is a variant of test above (\ref{params-string}), but use more realistic
parameter pass (by reference).

\lstinputlisting{string/params-ref/str.cc}

As in test above (\ref{params-string}) the \libstd{} show better time
by the same reason. But let's draw attention to the tendency: I remove
$1/3$ of string copy operations (two string copy operations remains in the test, no copy of strings while pass
parameter into function), and wall time of this test decline $1/3$ too.

If I will pass only const reference to string, then I will avoid any copy
operations and a difference in time between two approaches will disappear.

\subsection{Short string copy\label{params-short-string} (test \#6, \#7)}

This is a variant of test above (\ref{params-string}), but use ``short'' string
parameter pass. This test show effect of ``short string optimization'' technique
in \STLport{}. This technique use short buffer in the ``string'' instance,
this allow to skip memory allocation for short strings.

\lstinputlisting{string/params-short/str.cc}

Test \#6 is default \STLport{}, with ``short string optimization'', while
test \#7 present results without ``short string optimization''. In case of \libstd{}
tests \#6 and \#7 are the same.

\STLport{} was build with ``short string'' size 16. ``Short strings optimization'' give
test time $2.95\%$ longer then without ones (for strings with size 20, this test case
not shown on figures).
But you see, for ``short'' strings test with ``short'' strings optimization
show time that $43.3\%$ better!

\section{Role of Allocators}

The \STLport{} provide default ``optimized'' memory allocator
(\verb|node_alloc|). This allocator was used when I run strings tests
for \STLport{} (see section~\ref{TestsDescr}). May be the win of \STLport{} is
due to advanced memory allocation technique?

In the \STLport{} implemented three base memory allocators:
\begin{itemize}
  \item ``optimized'' \verb|node_alloc|;
  \item adapter around \verb|new| operator;
  \item adapter around \verb|malloc| call.
\end{itemize}

\begin{figure}
  \begin{center}
    \input alloc.tex
  \end{center}
  \caption{Role of memory allocator in strings implementation (\STLport).
           Wall time for tests. \label{STLport-alloc-strings}}
\end{figure}

Let's repeat tests from section~\ref{TestsDescr} for \STLport{} with different
allocators. We see (fig.~\ref{STLport-alloc-strings}) that all allocators
are good enough
%: only on test with lot amount of memory
%allocation/reallocation
%operations (test~1) the ``optimized'' \verb|node_alloc| has a tiny advantage
%(difference between best and worst allocators is $3\%$).
For search operations (test~2) the results as expected
are the same (within measure of inaccuracy). The tests 4 and 5 show
that cost of \verb|malloc| system call---\verb|node_alloc| reuse once
allocated memory. But copy of string's content still present (compare with time of
\libstd{} on fig.~\ref{STLport-gpp-strings}).

\section{Strings in Multithreaded Environment}

Memory allocation performance in single and multithreaded environments
is an important aspect of any application. The work with \CPP{}
strings in multithreaded environments is highly depends upon
underlying allocator.

The tests are the same as described in section~\ref{TestsDescr},
except that every test run simultaneously in two threads.


\subsection{Comparison of \STLport{} and \libstd}

\begin{figure}
  \begin{center}
    \input strings-MT.tex
  \end{center}
  \caption{Tests wall time (\libstd{} and \STLport{}
           strings) in  MT environment (two threads).
           \label{STLport-gpp-MT-strings}}
\end{figure}

\begin{figure}
  \begin{center}
    \input strings-MT2.tex
  \end{center}
  \caption{Tests wall time (\libstd{} and \STLport{}
           strings) in  MT environment (two threads) (same as fig.~\ref{STLport-gpp-MT-strings}, another scale).
           \label{STLport-gpp-MT-strings2}}
\end{figure}

The results (fig.~\ref{STLport-gpp-MT-strings}, \ref{STLport-gpp-MT-strings2}) are near
the same as shown on figure~\ref{STLport-gpp-strings}
except that for mix operations test (test~3, described in
section~\ref{mixed-string}) the \libstd's performance
degradate too much.

\subsection{Time Profile in \libstd}

\begin{figure}
  \begin{center}
    \input strings-MT-t-libstd.tex
  \end{center}
  \caption{
           Wall time, user time and system time per thread for 
           \libstd{} in MT environment.
           \label{gpp-MT-strings-t}}
\end{figure}

On figure~\ref{gpp-MT-strings-t} you can see user, system and wall
time for tests with \libstd{} strings implementation.
We see that both threads remain in user space almost all time.
This may be due to a lot of waiting state. 

As we can see in test~3, the general performance problem
is seems in a lot of thread synchronization operation
(a lot of system time, that is greater than
user time, in test~3 I can associate only with thread synchronization primitives).



\subsection{Time Profile in \STLport}

\begin{figure}
  \begin{center}
    \input strings-MT-t-stlp-n.tex
  \end{center}
  \caption{
           Wall time, user time and system time per thread for 
           \STLport{} (node allocator) in MT environment.
           \label{STLport-MT-strings-t}}
\end{figure}

\begin{figure}
  \begin{center}
    \input strings-MT-t-stlp-m.tex
  \end{center}
  \caption{
           Wall time, user time and system time per thread for 
           \STLport{} (malloc allocator) in MT environment.
           \label{STLport-MT-strings-m}}
\end{figure}

\begin{figure}
  \begin{center}
    \input strings-MT-t-stlp-r.tex
  \end{center}
  \caption{
           Wall time, user time and system time per thread for 
           \STLport{} ropes in MT environment.
           \label{STLport-MT-strings-r}}
\end{figure}

Figure~\ref{STLport-MT-strings-t} present user and system time per thread
and wall time for tests with STLport with
\texttt{node\_alloc}-based,
figure~\ref{STLport-MT-strings-m} show profile for tests with \texttt{malloc}-based allocators, and figure~\ref{STLport-MT-strings-r} for ropes.

The surprise for me was that \texttt{malloc}-based variant
win (in $1.5--2$ times faster) over \texttt{node\_alloc}-based variant in test~4
and test~5.
This fact can be explained by usage of memory allocated chunks vector
in \texttt{node\_alloc}. This vector accessed from different threads
and such access should use thread synchronization primitives.
Compare figures~\ref{STLport-alloc-strings} and \ref{STLport-gpp-MT-strings}.
The tests~1--2 has the same time in MT and non-MT context for
\texttt{malloc}-based and \texttt{node\_alloc}-based allocators.
In test~3 \texttt{malloc}-based variant climb down, while
\texttt{node\_alloc}-based keep position. 

\section{Strings vs. Ropes}

Some time ago, there are many discussions about complexity
of string assignment algorithm.
In this time 
SGI made experimental realization of standard string interfaces
with constant copy/insert/replace algorithm complexity---the \texttt{ropes}.

Really \texttt{ropes} and \texttt{strings} has different usage scope.
I use STLport implementation (that come from SGI \texttt{string} and \texttt{rope}
classes) to compare ones. You can see STLport story here:
\texttt{http://www.stlport.com/doc/story.html}.
Some words about \texttt{string} and \texttt{rope}
from first hands you can find here:\\
\texttt{http://www.sgi.com/tech/stl/string\_discussion.html}.

This test based on mix of copy, insert, append and replace
operations under classic strings or ropes. The main part
of test you can see on lines 21--30 (where \texttt{T} is
either \texttt{string} or \texttt{rope}).

\lstinputlisting{string/ropes/str.cc}

\begin{figure}
  \begin{center}
    \input str-rope.tex
  \end{center}
  \caption{Strings vs. Ropes.\label{STLport-rope-string}}
\end{figure}

\begin{figure}
  \begin{center}
    \input str-rope-1.tex
  \end{center}
  \caption{Strings vs. Ropes.\label{STLport-rope-string-1}}
\end{figure}

As expected, efforts to establish constant assign/insert/replace
algorithm complexity lead to
overhead---so ropes are preferable if you want to process
long strings (longer then 4K or 25--30K, depends upon compiler's optimization quality, as you can see on figures~\ref{STLport-rope-string} and~\ref{STLport-rope-string-1}).

Evident, that complexity of \texttt{string} operations is near the linear,
while \texttt{rope} has constant complexity. But the overhead
of \texttt{rope} is significant, so cost of constant algorithm complexity
is high enough.

Note, that behaviour of \texttt{rope} and \libstd{} \texttt{strings} implementation
alike in single-thread environment (fig.~\ref{STLport-gpp-strings}).

\section{References}

\noindent
\begin{description}
  \item[STLport] \texttt{http://www.stlport.com}
  \item[GCC]     \texttt{http://gcc.gnu.org}
  \item[SGI]     \texttt{http://www.sgi.com/tech/stl/}
  \item[Complement] \texttt{http://complement.sourceforge.net}
\end{description}



\end{document}
